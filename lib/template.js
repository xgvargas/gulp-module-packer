// Generated by CoffeeScript 1.10.0
var common, gutil, jsStringEscape, path, through;

through = require('through2');

gutil = require('gulp-util');

common = require('./common.js');

path = require('path');

jsStringEscape = require('js-string-escape');

module.exports.template = function(options) {
  var config, opt, past, ref, templates, transform;
  ref = common.prepare(options), opt = ref[0], config = ref[1];
  if (opt.wrapTemplate == null) {
    opt.wrapTemplate = function(name, content, opt) {
      if (opt.minify) {
        content = content.replace(/(?:<!--[\s\S]*?-->)|(?:\s*[\n\r]+\s*)/g, '');
        content = content.replace(/\s{2,}/g, ' ');
        content = content.replace(/\s>/g, '>');
        content = content.replace(/<\s/g, '<');
      }
      return "$templateCache.put('" + name + "', '" + (jsStringEscape(content)) + "');";
    };
  }
  if (opt.wrapFuntions == null) {
    opt.wrapFuntions = function(name, content, opt) {
      var alone;
      alone = opt.standalone ? ', []' : '';
      return "angular.module('" + name + "'" + alone + ").run([\"$templateCache\", function($templateCache) { " + content + "\n}]);";
    };
  }
  templates = {};
  transform = function(file, env, cb) {
    var filename, pack;
    if (file.isStream()) {
      this.emit('error', new PluginError('gulp-module-packer', 'Streaming not supported.'));
      return cb();
    }
    filename = file.relative.replace(/\\/g, '/');
    pack = path.dirname(filename);
    if (pack !== '.') {
      if (templates[pack] == null) {
        templates[pack] = '';
      }
      templates[pack] += '\n    ' + opt.wrapTemplate(filename, file.contents.toString(), opt.wrapOpt);
      if (!opt.keepConsumed) {
        return cb();
      }
    } else {
      if (!opt.keepUnpacked) {
        return cb();
      }
    }
    return cb(null, file);
  };
  past = function(cb) {
    var new_file, pack;
    for (pack in templates) {
      new_file = new gutil.File({
        cwd: "",
        base: "",
        path: pack + ".js",
        contents: new Buffer(opt.wrapFuntions(pack, templates[pack], opt.wrapOpt))
      });
      this.push(new_file);
    }
    return cb();
  };
  return through.obj(transform, past);
};
