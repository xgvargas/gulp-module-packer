// Generated by CoffeeScript 1.10.0
var PluginError, common, fs, gutil, path, stream, through;

through = require('through2');

fs = require('fs');

gutil = require('gulp-util');

common = require('./common.js');

path = require('path');

stream = require('stream');

PluginError = gutil.PluginError;

module.exports.concat = function(options) {
  var config, i, len, name, opt, pack, past, pushFiles, ref, ref1, transform, waitFor;
  ref = common.prepare(options), opt = ref[0], config = ref[1];
  if (typeof opt.block !== 'string') {
    throw new PluginError('gulp-module-packer', 'Missing `block` in options.');
  }
  if (opt.block !== 'js' && opt.block !== 'css') {
    throw new PluginError('gulp-module-packer', 'Invalid block.');
  }
  waitFor = {};
  pushFiles = function(obj) {
    var content, file, i, len, min, pack, ref1;
    for (pack in config[opt.block]) {
      content = opt.header;
      ref1 = config[opt.block][pack];
      for (i = 0, len = ref1.length; i < len; i++) {
        file = ref1[i];
        if (file[0] === ':' && file[1] === ':') {
          content += waitFor[file] + '\n';
        } else {
          content += fs.readFileSync(path.join(opt.base, file)) + "\n";
        }
      }
      min = opt.min ? '.min' : '';
      obj.push(new gutil.File({
        cwd: "",
        base: "",
        path: "" + pack + opt.hash + min + "." + opt.block,
        contents: new Buffer(content)
      }));
    }
  };
  if (opt.mode === 'pipe') {
    for (pack in config[opt.block]) {
      ref1 = config[opt.block][pack];
      for (i = 0, len = ref1.length; i < len; i++) {
        name = ref1[i];
        if (name[0] === ':' && name[1] === ':') {
          waitFor[name] = "/* === Oops! Can't find `" + name + "` in stream... === */";
        }
      }
    }
    transform = function(file, env, cb) {
      if (file.isStream()) {
        this.emit('error', new PluginError('gulp-module-packer', 'Streaming not supported.'));
        return cb();
      }
      name = '::' + file.relative.replace(/\\/g, '/');
      if (name in waitFor) {
        waitFor[name] = file.contents;
        if (!opt.keepConsumed) {
          return cb();
        }
      }
      return cb(null, file);
    };
    past = function(cb) {
      pushFiles(this);
      return cb();
    };
    return through.obj(transform, past);
  }
  if (opt.mode === 'src') {
    stream = new stream.Readable({
      objectMode: true,
      highWaterMark: 16
    });
    stream._read = function(chunk) {
      pushFiles(this);
      return this.push(null);
    };
    return stream;
  }
};
